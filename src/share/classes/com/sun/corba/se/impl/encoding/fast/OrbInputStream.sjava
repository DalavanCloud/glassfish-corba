/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 * 
 * Copyright (c) 1997-2010 Oracle and/or its affiliates. All rights reserved.
 * 
 * The contents of this file are subject to the terms of either the GNU
 * General Public License Version 2 only ("GPL") or the Common Development
 * and Distribution License("CDDL") (collectively, the "License").  You
 * may not use this file except in compliance with the License.  You can
 * obtain a copy of the License at
 * https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
 * or packager/legal/LICENSE.txt.  See the License for the specific
 * language governing permissions and limitations under the License.
 * 
 * When distributing the software, include this License Header Notice in each
 * file and include the License file at glassfish/bootstrap/legal/LICENSE.txt.
 * 
 * GPL Classpath Exception:
 * Oracle designates this particular file as subject to the "Classpath"
 * exception as provided by Oracle in the GPL Version 2 section of the License
 * file that accompanied this code.
 * 
 * Modifications:
 * If applicable, add the following below the License Header, with the fields
 * enclosed by brackets [] replaced by your own identifying information:
 * "Portions Copyright [year] [name of copyright owner]"
 * 
 * Contributor(s):
 * If you wish your version of this file to be governed by only the CDDL or
 * only the GPL Version 2, indicate your decision by adding "[Contributor]
 * elects to include this software in this distribution under the [CDDL or GPL
 * Version 2] license."  If you don't indicate a single choice of license, a
 * recipient has the option to distribute your version of this file under
 * either the CDDL, the GPL Version 2 or to extend the choice of license to
 * its licensees as provided above.  However, if you add GPL Version 2 code
 * and therefore, elected the GPL Version 2 license, then the option applies
 * only if the new code is made subject to such option by the copyright
 * holder.
 */
package com.sun.corba.se.impl.encoding.fast ;

import org.omg.CORBA_2_3.portable.InputStream ;
import org.omg.CORBA.DataInputStream ;
import org.omg.CORBA.portable.ValueBase ;
import org.omg.CORBA.portable.ValueInputStream ;

// The type used in the CORBAMessageMediatorImpl is CDROutputObject/CDRInputObject
// These types may actually be exposed as OutputObject/InputObject
// Dynamic RMI-IIOP just uses CORBA_2_3 InputStream/OutputStream
//
// Note that our main goal is to accelerate RMI-IIOP.  IDL cannot be accelerated
// without imposing constraints on the RMI-IIOP case, or modifying the way that
// IDL marshaling code is generated and the entire IDL/Java marshaling API
// (Basic problem: IDL structs and value types are marshaled by generated code,
// not the ORB, so the ORB has no chance to intercept the code).  Note that IDL
// delegates handling of value types to the ORB, but structs and unions are still
// an issue.  If we look at recursive struct and unions, all that the ORB sees is 
// a sequence of writes of primitive types, and the ORB has no way to re-order that
// sequence for more efficient marshaling.  So, the obvious solution is to default
// the marshaling process to order-preserving, so that any standard IDL-generated
// marshaling code works, and have RMI-IIOP set a flag that allows for parallelized 
// marshaling.
//
// Basic architecture:
// Low-level:  
//	This is the low-level API that handles primitive type encoding. Its
//	implementation is fairly simple, but it must be very fast.  It also may 
//	interact with buffering decisions, such as collect/grow/fragment.
//	Methods:
//	    read/write boolean char short int long float double
//	    read/write array of boolean char short int long float double
//	Interface: PrimitiveXXXStream
//	Implementation for Fast, non-recursive encoding (needs a name/acronym
//	    (Flat something, Flat Data Representation, also byte-coded
//	     F BC DR ByCoFl or perhaps Exploded. Also self-describing.
//	     DataRepresentation
//	    PrimitveXXXStreamYYYImpl
// High-level: 
//	This handles more complex data types primarily in terms of the low-level API,
//	but may also include encoding-specific details (such as writing out a header
//	for the start of an object).
//	Methods:
//	    read/write value (4 versions) abstract_interface Object TypeCode Any
// Adapter: IdlXXXStreamAdapter is an abstract class that implements CORBA_2_3 XXXStream. 
//	handle idl->java differences (ushort ulong ulonglong, 
//	read_abstract_interface() simply calls read_abstract_interface( Class ) with a null,
//	read_value() calls read_value( Class ) with a null).  We still need 4 versions
//	of read_value.  Also proxies low-level ops to PrimitiveXXXStream, high-level to
//	ComplexXXXStream.
// Constructing a ComplexXXXStream requires a PrimitiveXXXStream.  All of these (complex,
// primitive, and adapter) require factories.

public interface OrbInputStream extends InputStream
    implements MarshalInputStream, DataInputStream, ValueInputStream {

    // From  CORBA_2_3 InputStream
    public java.io.Serializable read_value() ; 
    public java.io.Serializable read_value(java.lang.Class clz) ; 
    public java.io.Serializable read_value(org.omg.CORBA.portable.BoxedValueHelper factory) ;
    public java.io.Serializable read_value(java.lang.String rep_id) ;
    public java.io.Serializable read_value(java.io.Serializable value) ;
    public java.lang.Object read_abstract_interface() ;
    public java.lang.Object read_abstract_interface(java.lang.Class clz) ;

    // from CORBA InputStream 
    public boolean	read_boolean();
    public char		read_char();
    public char		read_wchar();
    public byte		read_octet();
    public short	read_short();
    public short	read_ushort();
    public int		read_long();
    public int		read_ulong();
    public long		read_longlong();
    public long		read_ulonglong();
    public float	read_float();
    public double	read_double();
    public String	read_string();
    public String	read_wstring();
    public void	read_boolean_array(boolean[] value, int offset, int length);
    public void	read_char_array(char[] value, int offset, int length);
    public void	read_wchar_array(char[] value, int offset, int length);
    public void	read_octet_array(byte[] value, int offset, int length);
    public void	read_short_array(short[] value, int offset, int length);
    public void	read_ushort_array(short[] value, int offset, int length);
    public void	read_long_array(int[] value, int offset, int length);
    public void	read_ulong_array(int[] value, int offset, int length);
    public void	read_longlong_array(long[] value, int offset, int length);
    public void	read_ulonglong_array(long[] value, int offset, int length);
    public void	read_float_array(float[] value, int offset, int length);
    public void	read_double_array(double[] value, int offset, int length);
    public org.omg.CORBA.Object read_Object();
    public TypeCode	read_TypeCode();
    public Any		read_any();

    // @Deprecated
    public  org.omg.CORBA.Principal	read_Principal() ;
    public int read() throws java.io.IOException ;
    public java.math.BigDecimal read_fixed() ;
    public org.omg.CORBA.Context read_Context() ;
    public  org.omg.CORBA.Object read_Object(java.lang.Class clz) ;
    public org.omg.CORBA.ORB orb() ;
    
    // from MarshalInputStream (which duplicates many methods in InputStream:
    // all of the read_XXX primitives, the read_XXX_array methods. read_Object(),
    // read_Object(Class), read_TypeCode, read_any, read_Principal, and read_value().

    public void consumeEndian();

    public int getPosition();
    public void mark(int readAheadLimit);
    public void reset();
    public void performORBVersionSpecificInit();
    public void resetCodeSetConverters();

    // from DataInputStream
    // Again, many methods are duplicated
    // read_longdouble not supported by IDL/Java mapping
    java.lang.Object read_Abstract ();
    java.io.Serializable read_Value ();
    void read_any_array (org.omg.CORBA.AnySeqHolder seq, int offset, int length);

    // from ValueBase
    String[] _truncatable_ids();

    // from ValueInputStream
    // Called from io IIOP* classes
    void start_value() ;
    void end_value() ;
}

